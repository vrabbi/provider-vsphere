// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type VSphereDistributedPortGroupInitParameters struct {

	// List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	ActiveUplinks []*string `json:"activeUplinks,omitempty" tf:"active_uplinks,omitempty"`

	// Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than that of its own.
	AllowForgedTransmits *bool `json:"allowForgedTransmits,omitempty" tf:"allow_forged_transmits,omitempty"`

	// Controls whether or not the Media Access Control (MAC) address can be changed.
	AllowMacChanges *bool `json:"allowMacChanges,omitempty" tf:"allow_mac_changes,omitempty"`

	// Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
	AllowPromiscuous *bool `json:"allowPromiscuous,omitempty" tf:"allow_promiscuous,omitempty"`

	// Allows the port group to create additional ports
	// past the limit specified in number_of_ports if necessary. Default: true.
	// Auto-expands the port group beyond the port count configured in number_of_ports when necessary.
	AutoExpand *bool `json:"autoExpand,omitempty" tf:"auto_expand,omitempty"`

	// Indicates whether to block all ports by default.
	BlockAllPorts *bool `json:"blockAllPorts,omitempty" tf:"block_all_ports,omitempty"`

	// Allow the port shutdown
	// policy to be overridden on an individual port.
	// Allow the blocked setting of an individual port to override the setting in the portgroup.
	BlockOverrideAllowed *bool `json:"blockOverrideAllowed,omitempty" tf:"block_override_allowed,omitempty"`

	// Enable beacon probing on the ports this policy applies to.
	CheckBeacon *bool `json:"checkBeacon,omitempty" tf:"check_beacon,omitempty"`

	// Map of custom attribute ids to attribute
	// value string to set for port group. See here
	// for a reference on how to set values for custom attributes.
	// A list of custom attributes to set on this resource.
	// +mapType=granular
	CustomAttributes map[string]*string `json:"customAttributes,omitempty" tf:"custom_attributes,omitempty"`

	// An optional description for the port group.
	// The description of the portgroup.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Allow VMDirectPath Gen2 on the ports this policy applies to.
	DirectpathGen2Allowed *bool `json:"directpathGen2Allowed,omitempty" tf:"directpath_gen2_allowed,omitempty"`

	// The ID of the VDS to add the
	// port group to. Forces a new resource if changed.
	// The UUID of the DVS to attach this port group to.
	DistributedVirtualSwitchUUID *string `json:"distributedVirtualSwitchUuid,omitempty" tf:"distributed_virtual_switch_uuid,omitempty"`

	// The average egress bandwidth in bits per second if egress shaping is enabled on the port.
	EgressShapingAverageBandwidth *float64 `json:"egressShapingAverageBandwidth,omitempty" tf:"egress_shaping_average_bandwidth,omitempty"`

	// The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
	EgressShapingBurstSize *float64 `json:"egressShapingBurstSize,omitempty" tf:"egress_shaping_burst_size,omitempty"`

	// True if the traffic shaper is enabled for egress traffic on the port.
	EgressShapingEnabled *bool `json:"egressShapingEnabled,omitempty" tf:"egress_shaping_enabled,omitempty"`

	// The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
	EgressShapingPeakBandwidth *float64 `json:"egressShapingPeakBandwidth,omitempty" tf:"egress_shaping_peak_bandwidth,omitempty"`

	// If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
	Failback *bool `json:"failback,omitempty" tf:"failback,omitempty"`

	// The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
	IngressShapingAverageBandwidth *float64 `json:"ingressShapingAverageBandwidth,omitempty" tf:"ingress_shaping_average_bandwidth,omitempty"`

	// The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
	IngressShapingBurstSize *float64 `json:"ingressShapingBurstSize,omitempty" tf:"ingress_shaping_burst_size,omitempty"`

	// True if the traffic shaper is enabled for ingress traffic on the port.
	IngressShapingEnabled *bool `json:"ingressShapingEnabled,omitempty" tf:"ingress_shaping_enabled,omitempty"`

	// The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
	IngressShapingPeakBandwidth *float64 `json:"ingressShapingPeakBandwidth,omitempty" tf:"ingress_shaping_peak_bandwidth,omitempty"`

	// Whether or not to enable LACP on all uplink ports.
	LacpEnabled *bool `json:"lacpEnabled,omitempty" tf:"lacp_enabled,omitempty"`

	// The uplink LACP mode to use. Can be one of active or passive.
	LacpMode *string `json:"lacpMode,omitempty" tf:"lacp_mode,omitempty"`

	// Allow a port in this port group to be
	// moved to another port group while it is connected.
	// Allow a live port to be moved in and out of the portgroup.
	LivePortMovingAllowed *bool `json:"livePortMovingAllowed,omitempty" tf:"live_port_moving_allowed,omitempty"`

	// The name of the port group.
	// The name of the portgroup.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Indicates whether to enable netflow on all ports.
	NetflowEnabled *bool `json:"netflowEnabled,omitempty" tf:"netflow_enabled,omitempty"`

	// Allow the
	// Netflow policy on this port group to be overridden on an
	// individual port.
	// Allow the enabling or disabling of Netflow on a port, contrary to the policy in the portgroup.
	NetflowOverrideAllowed *bool `json:"netflowOverrideAllowed,omitempty" tf:"netflow_override_allowed,omitempty"`

	// The key of a network resource pool
	// to associate with this port group. The default is -1, which implies no
	// association.
	// The key of a network resource pool to associate with this portgroup.
	NetworkResourcePoolKey *string `json:"networkResourcePoolKey,omitempty" tf:"network_resource_pool_key,omitempty"`

	// Allow the network
	// resource pool set on this port group to be overridden on an individual port.
	// Allow the network resource pool of an individual port to override the setting in the portgroup.
	NetworkResourcePoolOverrideAllowed *bool `json:"networkResourcePoolOverrideAllowed,omitempty" tf:"network_resource_pool_override_allowed,omitempty"`

	// If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
	NotifySwitches *bool `json:"notifySwitches,omitempty" tf:"notify_switches,omitempty"`

	// The number of ports available on this port
	// group. Cannot be decreased below the amount of used ports on the port group.
	// The number of ports in this portgroup. The DVS will expand and shrink by modifying this setting.
	NumberOfPorts *float64 `json:"numberOfPorts,omitempty" tf:"number_of_ports,omitempty"`

	// Reset a port's settings to the
	// settings defined on this port group policy when the port disconnects.
	// Reset the setting of any ports in this portgroup back to the default setting when the port disconnects.
	PortConfigResetAtDisconnect *bool `json:"portConfigResetAtDisconnect,omitempty" tf:"port_config_reset_at_disconnect,omitempty"`

	// An optional formatting policy for naming of
	// the ports in this port group. See the portNameFormat attribute listed
	// here for details on the format syntax.
	// A template string to use when creating ports in the portgroup.
	PortNameFormat *string `json:"portNameFormat,omitempty" tf:"port_name_format,omitempty"`

	// Used to define a secondary VLAN
	// ID when using private VLANs.
	// The secondary VLAN ID for this port.
	PortPrivateSecondaryVlanID *float64 `json:"portPrivateSecondaryVlanId,omitempty" tf:"port_private_secondary_vlan_id,omitempty"`

	// Allow the
	// security policy settings defined in this port group
	// policy to be overridden on an individual port.
	// Allow security policy settings on a port to override those on the portgroup.
	SecurityPolicyOverrideAllowed *bool `json:"securityPolicyOverrideAllowed,omitempty" tf:"security_policy_override_allowed,omitempty"`

	// Allow the
	// traffic shaping options on this port group policy
	// to be overridden on an individual port.
	// Allow the traffic shaping policies of an individual port to override the settings in the portgroup.
	ShapingOverrideAllowed *bool `json:"shapingOverrideAllowed,omitempty" tf:"shaping_override_allowed,omitempty"`

	// List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	StandbyUplinks []*string `json:"standbyUplinks,omitempty" tf:"standby_uplinks,omitempty"`

	// A list of tag IDs to apply to this object.
	// +listType=set
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, failover_explicit, or loadbalance_loadbased.
	TeamingPolicy *string `json:"teamingPolicy,omitempty" tf:"teaming_policy,omitempty"`

	// Allow any traffic filters on
	// this port group to be overridden on an individual port.
	// Allow any filter policies set on the individual port to override those in the portgroup.
	TrafficFilterOverrideAllowed *bool `json:"trafficFilterOverrideAllowed,omitempty" tf:"traffic_filter_override_allowed,omitempty"`

	// If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet forwarded done by the switch.
	TxUplink *bool `json:"txUplink,omitempty" tf:"tx_uplink,omitempty"`

	// The port group type. Can be one of earlyBinding (static
	// binding) or ephemeral. Default: earlyBinding.
	// The type of portgroup. Can be one of earlyBinding (static) or ephemeral.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Allow the
	// uplink teaming options on this port group to be
	// overridden on an individual port.
	// Allow the uplink teaming policies on a port to override those on the portgroup.
	UplinkTeamingOverrideAllowed *bool `json:"uplinkTeamingOverrideAllowed,omitempty" tf:"uplink_teaming_override_allowed,omitempty"`

	// The member VLAN for the ports this policy applies to. A
	// value of 0 means no VLAN.
	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	VlanID *float64 `json:"vlanId,omitempty" tf:"vlan_id,omitempty"`

	// Allow the
	// VLAN settings on this port group to be overridden on an
	// individual port.
	// Allow the VLAN configuration on a port to override those on the portgroup.
	VlanOverrideAllowed *bool `json:"vlanOverrideAllowed,omitempty" tf:"vlan_override_allowed,omitempty"`

	// Used to denote VLAN trunking. Use the min_vlan
	// and max_vlan sub-arguments to define the tagged VLAN range. Multiple
	// vlan_range definitions are allowed, but they must not overlap. Example
	// below:
	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	VlanRange []VlanRangeInitParameters `json:"vlanRange,omitempty" tf:"vlan_range,omitempty"`
}

type VSphereDistributedPortGroupObservation struct {

	// List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	ActiveUplinks []*string `json:"activeUplinks,omitempty" tf:"active_uplinks,omitempty"`

	// Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than that of its own.
	AllowForgedTransmits *bool `json:"allowForgedTransmits,omitempty" tf:"allow_forged_transmits,omitempty"`

	// Controls whether or not the Media Access Control (MAC) address can be changed.
	AllowMacChanges *bool `json:"allowMacChanges,omitempty" tf:"allow_mac_changes,omitempty"`

	// Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
	AllowPromiscuous *bool `json:"allowPromiscuous,omitempty" tf:"allow_promiscuous,omitempty"`

	// Allows the port group to create additional ports
	// past the limit specified in number_of_ports if necessary. Default: true.
	// Auto-expands the port group beyond the port count configured in number_of_ports when necessary.
	AutoExpand *bool `json:"autoExpand,omitempty" tf:"auto_expand,omitempty"`

	// Indicates whether to block all ports by default.
	BlockAllPorts *bool `json:"blockAllPorts,omitempty" tf:"block_all_ports,omitempty"`

	// Allow the port shutdown
	// policy to be overridden on an individual port.
	// Allow the blocked setting of an individual port to override the setting in the portgroup.
	BlockOverrideAllowed *bool `json:"blockOverrideAllowed,omitempty" tf:"block_override_allowed,omitempty"`

	// Enable beacon probing on the ports this policy applies to.
	CheckBeacon *bool `json:"checkBeacon,omitempty" tf:"check_beacon,omitempty"`

	// : The current version of the port group configuration,
	// incremented by subsequent updates to the port group.
	// Version string of the configuration that this spec is trying to change.
	ConfigVersion *string `json:"configVersion,omitempty" tf:"config_version,omitempty"`

	// Map of custom attribute ids to attribute
	// value string to set for port group. See here
	// for a reference on how to set values for custom attributes.
	// A list of custom attributes to set on this resource.
	// +mapType=granular
	CustomAttributes map[string]*string `json:"customAttributes,omitempty" tf:"custom_attributes,omitempty"`

	// An optional description for the port group.
	// The description of the portgroup.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Allow VMDirectPath Gen2 on the ports this policy applies to.
	DirectpathGen2Allowed *bool `json:"directpathGen2Allowed,omitempty" tf:"directpath_gen2_allowed,omitempty"`

	// The ID of the VDS to add the
	// port group to. Forces a new resource if changed.
	// The UUID of the DVS to attach this port group to.
	DistributedVirtualSwitchUUID *string `json:"distributedVirtualSwitchUuid,omitempty" tf:"distributed_virtual_switch_uuid,omitempty"`

	// The average egress bandwidth in bits per second if egress shaping is enabled on the port.
	EgressShapingAverageBandwidth *float64 `json:"egressShapingAverageBandwidth,omitempty" tf:"egress_shaping_average_bandwidth,omitempty"`

	// The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
	EgressShapingBurstSize *float64 `json:"egressShapingBurstSize,omitempty" tf:"egress_shaping_burst_size,omitempty"`

	// True if the traffic shaper is enabled for egress traffic on the port.
	EgressShapingEnabled *bool `json:"egressShapingEnabled,omitempty" tf:"egress_shaping_enabled,omitempty"`

	// The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
	EgressShapingPeakBandwidth *float64 `json:"egressShapingPeakBandwidth,omitempty" tf:"egress_shaping_peak_bandwidth,omitempty"`

	// If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
	Failback *bool `json:"failback,omitempty" tf:"failback,omitempty"`

	// : The managed object reference ID of the created
	// port group.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
	IngressShapingAverageBandwidth *float64 `json:"ingressShapingAverageBandwidth,omitempty" tf:"ingress_shaping_average_bandwidth,omitempty"`

	// The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
	IngressShapingBurstSize *float64 `json:"ingressShapingBurstSize,omitempty" tf:"ingress_shaping_burst_size,omitempty"`

	// True if the traffic shaper is enabled for ingress traffic on the port.
	IngressShapingEnabled *bool `json:"ingressShapingEnabled,omitempty" tf:"ingress_shaping_enabled,omitempty"`

	// The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
	IngressShapingPeakBandwidth *float64 `json:"ingressShapingPeakBandwidth,omitempty" tf:"ingress_shaping_peak_bandwidth,omitempty"`

	// : The generated UUID of the port group.
	// The generated UUID of the portgroup.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// Whether or not to enable LACP on all uplink ports.
	LacpEnabled *bool `json:"lacpEnabled,omitempty" tf:"lacp_enabled,omitempty"`

	// The uplink LACP mode to use. Can be one of active or passive.
	LacpMode *string `json:"lacpMode,omitempty" tf:"lacp_mode,omitempty"`

	// Allow a port in this port group to be
	// moved to another port group while it is connected.
	// Allow a live port to be moved in and out of the portgroup.
	LivePortMovingAllowed *bool `json:"livePortMovingAllowed,omitempty" tf:"live_port_moving_allowed,omitempty"`

	// The name of the port group.
	// The name of the portgroup.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Indicates whether to enable netflow on all ports.
	NetflowEnabled *bool `json:"netflowEnabled,omitempty" tf:"netflow_enabled,omitempty"`

	// Allow the
	// Netflow policy on this port group to be overridden on an
	// individual port.
	// Allow the enabling or disabling of Netflow on a port, contrary to the policy in the portgroup.
	NetflowOverrideAllowed *bool `json:"netflowOverrideAllowed,omitempty" tf:"netflow_override_allowed,omitempty"`

	// The key of a network resource pool
	// to associate with this port group. The default is -1, which implies no
	// association.
	// The key of a network resource pool to associate with this portgroup.
	NetworkResourcePoolKey *string `json:"networkResourcePoolKey,omitempty" tf:"network_resource_pool_key,omitempty"`

	// Allow the network
	// resource pool set on this port group to be overridden on an individual port.
	// Allow the network resource pool of an individual port to override the setting in the portgroup.
	NetworkResourcePoolOverrideAllowed *bool `json:"networkResourcePoolOverrideAllowed,omitempty" tf:"network_resource_pool_override_allowed,omitempty"`

	// If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
	NotifySwitches *bool `json:"notifySwitches,omitempty" tf:"notify_switches,omitempty"`

	// The number of ports available on this port
	// group. Cannot be decreased below the amount of used ports on the port group.
	// The number of ports in this portgroup. The DVS will expand and shrink by modifying this setting.
	NumberOfPorts *float64 `json:"numberOfPorts,omitempty" tf:"number_of_ports,omitempty"`

	// Reset a port's settings to the
	// settings defined on this port group policy when the port disconnects.
	// Reset the setting of any ports in this portgroup back to the default setting when the port disconnects.
	PortConfigResetAtDisconnect *bool `json:"portConfigResetAtDisconnect,omitempty" tf:"port_config_reset_at_disconnect,omitempty"`

	// An optional formatting policy for naming of
	// the ports in this port group. See the portNameFormat attribute listed
	// here for details on the format syntax.
	// A template string to use when creating ports in the portgroup.
	PortNameFormat *string `json:"portNameFormat,omitempty" tf:"port_name_format,omitempty"`

	// Used to define a secondary VLAN
	// ID when using private VLANs.
	// The secondary VLAN ID for this port.
	PortPrivateSecondaryVlanID *float64 `json:"portPrivateSecondaryVlanId,omitempty" tf:"port_private_secondary_vlan_id,omitempty"`

	// Allow the
	// security policy settings defined in this port group
	// policy to be overridden on an individual port.
	// Allow security policy settings on a port to override those on the portgroup.
	SecurityPolicyOverrideAllowed *bool `json:"securityPolicyOverrideAllowed,omitempty" tf:"security_policy_override_allowed,omitempty"`

	// Allow the
	// traffic shaping options on this port group policy
	// to be overridden on an individual port.
	// Allow the traffic shaping policies of an individual port to override the settings in the portgroup.
	ShapingOverrideAllowed *bool `json:"shapingOverrideAllowed,omitempty" tf:"shaping_override_allowed,omitempty"`

	// List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	StandbyUplinks []*string `json:"standbyUplinks,omitempty" tf:"standby_uplinks,omitempty"`

	// A list of tag IDs to apply to this object.
	// +listType=set
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, failover_explicit, or loadbalance_loadbased.
	TeamingPolicy *string `json:"teamingPolicy,omitempty" tf:"teaming_policy,omitempty"`

	// Allow any traffic filters on
	// this port group to be overridden on an individual port.
	// Allow any filter policies set on the individual port to override those in the portgroup.
	TrafficFilterOverrideAllowed *bool `json:"trafficFilterOverrideAllowed,omitempty" tf:"traffic_filter_override_allowed,omitempty"`

	// If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet forwarded done by the switch.
	TxUplink *bool `json:"txUplink,omitempty" tf:"tx_uplink,omitempty"`

	// The port group type. Can be one of earlyBinding (static
	// binding) or ephemeral. Default: earlyBinding.
	// The type of portgroup. Can be one of earlyBinding (static) or ephemeral.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Allow the
	// uplink teaming options on this port group to be
	// overridden on an individual port.
	// Allow the uplink teaming policies on a port to override those on the portgroup.
	UplinkTeamingOverrideAllowed *bool `json:"uplinkTeamingOverrideAllowed,omitempty" tf:"uplink_teaming_override_allowed,omitempty"`

	// The member VLAN for the ports this policy applies to. A
	// value of 0 means no VLAN.
	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	VlanID *float64 `json:"vlanId,omitempty" tf:"vlan_id,omitempty"`

	// Allow the
	// VLAN settings on this port group to be overridden on an
	// individual port.
	// Allow the VLAN configuration on a port to override those on the portgroup.
	VlanOverrideAllowed *bool `json:"vlanOverrideAllowed,omitempty" tf:"vlan_override_allowed,omitempty"`

	// Used to denote VLAN trunking. Use the min_vlan
	// and max_vlan sub-arguments to define the tagged VLAN range. Multiple
	// vlan_range definitions are allowed, but they must not overlap. Example
	// below:
	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	VlanRange []VlanRangeObservation `json:"vlanRange,omitempty" tf:"vlan_range,omitempty"`
}

type VSphereDistributedPortGroupParameters struct {

	// List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	// +kubebuilder:validation:Optional
	ActiveUplinks []*string `json:"activeUplinks,omitempty" tf:"active_uplinks,omitempty"`

	// Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than that of its own.
	// +kubebuilder:validation:Optional
	AllowForgedTransmits *bool `json:"allowForgedTransmits,omitempty" tf:"allow_forged_transmits,omitempty"`

	// Controls whether or not the Media Access Control (MAC) address can be changed.
	// +kubebuilder:validation:Optional
	AllowMacChanges *bool `json:"allowMacChanges,omitempty" tf:"allow_mac_changes,omitempty"`

	// Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
	// +kubebuilder:validation:Optional
	AllowPromiscuous *bool `json:"allowPromiscuous,omitempty" tf:"allow_promiscuous,omitempty"`

	// Allows the port group to create additional ports
	// past the limit specified in number_of_ports if necessary. Default: true.
	// Auto-expands the port group beyond the port count configured in number_of_ports when necessary.
	// +kubebuilder:validation:Optional
	AutoExpand *bool `json:"autoExpand,omitempty" tf:"auto_expand,omitempty"`

	// Indicates whether to block all ports by default.
	// +kubebuilder:validation:Optional
	BlockAllPorts *bool `json:"blockAllPorts,omitempty" tf:"block_all_ports,omitempty"`

	// Allow the port shutdown
	// policy to be overridden on an individual port.
	// Allow the blocked setting of an individual port to override the setting in the portgroup.
	// +kubebuilder:validation:Optional
	BlockOverrideAllowed *bool `json:"blockOverrideAllowed,omitempty" tf:"block_override_allowed,omitempty"`

	// Enable beacon probing on the ports this policy applies to.
	// +kubebuilder:validation:Optional
	CheckBeacon *bool `json:"checkBeacon,omitempty" tf:"check_beacon,omitempty"`

	// Map of custom attribute ids to attribute
	// value string to set for port group. See here
	// for a reference on how to set values for custom attributes.
	// A list of custom attributes to set on this resource.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	CustomAttributes map[string]*string `json:"customAttributes,omitempty" tf:"custom_attributes,omitempty"`

	// An optional description for the port group.
	// The description of the portgroup.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Allow VMDirectPath Gen2 on the ports this policy applies to.
	// +kubebuilder:validation:Optional
	DirectpathGen2Allowed *bool `json:"directpathGen2Allowed,omitempty" tf:"directpath_gen2_allowed,omitempty"`

	// The ID of the VDS to add the
	// port group to. Forces a new resource if changed.
	// The UUID of the DVS to attach this port group to.
	// +kubebuilder:validation:Optional
	DistributedVirtualSwitchUUID *string `json:"distributedVirtualSwitchUuid,omitempty" tf:"distributed_virtual_switch_uuid,omitempty"`

	// The average egress bandwidth in bits per second if egress shaping is enabled on the port.
	// +kubebuilder:validation:Optional
	EgressShapingAverageBandwidth *float64 `json:"egressShapingAverageBandwidth,omitempty" tf:"egress_shaping_average_bandwidth,omitempty"`

	// The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
	// +kubebuilder:validation:Optional
	EgressShapingBurstSize *float64 `json:"egressShapingBurstSize,omitempty" tf:"egress_shaping_burst_size,omitempty"`

	// True if the traffic shaper is enabled for egress traffic on the port.
	// +kubebuilder:validation:Optional
	EgressShapingEnabled *bool `json:"egressShapingEnabled,omitempty" tf:"egress_shaping_enabled,omitempty"`

	// The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
	// +kubebuilder:validation:Optional
	EgressShapingPeakBandwidth *float64 `json:"egressShapingPeakBandwidth,omitempty" tf:"egress_shaping_peak_bandwidth,omitempty"`

	// If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
	// +kubebuilder:validation:Optional
	Failback *bool `json:"failback,omitempty" tf:"failback,omitempty"`

	// The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
	// +kubebuilder:validation:Optional
	IngressShapingAverageBandwidth *float64 `json:"ingressShapingAverageBandwidth,omitempty" tf:"ingress_shaping_average_bandwidth,omitempty"`

	// The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
	// +kubebuilder:validation:Optional
	IngressShapingBurstSize *float64 `json:"ingressShapingBurstSize,omitempty" tf:"ingress_shaping_burst_size,omitempty"`

	// True if the traffic shaper is enabled for ingress traffic on the port.
	// +kubebuilder:validation:Optional
	IngressShapingEnabled *bool `json:"ingressShapingEnabled,omitempty" tf:"ingress_shaping_enabled,omitempty"`

	// The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
	// +kubebuilder:validation:Optional
	IngressShapingPeakBandwidth *float64 `json:"ingressShapingPeakBandwidth,omitempty" tf:"ingress_shaping_peak_bandwidth,omitempty"`

	// Whether or not to enable LACP on all uplink ports.
	// +kubebuilder:validation:Optional
	LacpEnabled *bool `json:"lacpEnabled,omitempty" tf:"lacp_enabled,omitempty"`

	// The uplink LACP mode to use. Can be one of active or passive.
	// +kubebuilder:validation:Optional
	LacpMode *string `json:"lacpMode,omitempty" tf:"lacp_mode,omitempty"`

	// Allow a port in this port group to be
	// moved to another port group while it is connected.
	// Allow a live port to be moved in and out of the portgroup.
	// +kubebuilder:validation:Optional
	LivePortMovingAllowed *bool `json:"livePortMovingAllowed,omitempty" tf:"live_port_moving_allowed,omitempty"`

	// The name of the port group.
	// The name of the portgroup.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Indicates whether to enable netflow on all ports.
	// +kubebuilder:validation:Optional
	NetflowEnabled *bool `json:"netflowEnabled,omitempty" tf:"netflow_enabled,omitempty"`

	// Allow the
	// Netflow policy on this port group to be overridden on an
	// individual port.
	// Allow the enabling or disabling of Netflow on a port, contrary to the policy in the portgroup.
	// +kubebuilder:validation:Optional
	NetflowOverrideAllowed *bool `json:"netflowOverrideAllowed,omitempty" tf:"netflow_override_allowed,omitempty"`

	// The key of a network resource pool
	// to associate with this port group. The default is -1, which implies no
	// association.
	// The key of a network resource pool to associate with this portgroup.
	// +kubebuilder:validation:Optional
	NetworkResourcePoolKey *string `json:"networkResourcePoolKey,omitempty" tf:"network_resource_pool_key,omitempty"`

	// Allow the network
	// resource pool set on this port group to be overridden on an individual port.
	// Allow the network resource pool of an individual port to override the setting in the portgroup.
	// +kubebuilder:validation:Optional
	NetworkResourcePoolOverrideAllowed *bool `json:"networkResourcePoolOverrideAllowed,omitempty" tf:"network_resource_pool_override_allowed,omitempty"`

	// If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
	// +kubebuilder:validation:Optional
	NotifySwitches *bool `json:"notifySwitches,omitempty" tf:"notify_switches,omitempty"`

	// The number of ports available on this port
	// group. Cannot be decreased below the amount of used ports on the port group.
	// The number of ports in this portgroup. The DVS will expand and shrink by modifying this setting.
	// +kubebuilder:validation:Optional
	NumberOfPorts *float64 `json:"numberOfPorts,omitempty" tf:"number_of_ports,omitempty"`

	// Reset a port's settings to the
	// settings defined on this port group policy when the port disconnects.
	// Reset the setting of any ports in this portgroup back to the default setting when the port disconnects.
	// +kubebuilder:validation:Optional
	PortConfigResetAtDisconnect *bool `json:"portConfigResetAtDisconnect,omitempty" tf:"port_config_reset_at_disconnect,omitempty"`

	// An optional formatting policy for naming of
	// the ports in this port group. See the portNameFormat attribute listed
	// here for details on the format syntax.
	// A template string to use when creating ports in the portgroup.
	// +kubebuilder:validation:Optional
	PortNameFormat *string `json:"portNameFormat,omitempty" tf:"port_name_format,omitempty"`

	// Used to define a secondary VLAN
	// ID when using private VLANs.
	// The secondary VLAN ID for this port.
	// +kubebuilder:validation:Optional
	PortPrivateSecondaryVlanID *float64 `json:"portPrivateSecondaryVlanId,omitempty" tf:"port_private_secondary_vlan_id,omitempty"`

	// Allow the
	// security policy settings defined in this port group
	// policy to be overridden on an individual port.
	// Allow security policy settings on a port to override those on the portgroup.
	// +kubebuilder:validation:Optional
	SecurityPolicyOverrideAllowed *bool `json:"securityPolicyOverrideAllowed,omitempty" tf:"security_policy_override_allowed,omitempty"`

	// Allow the
	// traffic shaping options on this port group policy
	// to be overridden on an individual port.
	// Allow the traffic shaping policies of an individual port to override the settings in the portgroup.
	// +kubebuilder:validation:Optional
	ShapingOverrideAllowed *bool `json:"shapingOverrideAllowed,omitempty" tf:"shaping_override_allowed,omitempty"`

	// List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	// +kubebuilder:validation:Optional
	StandbyUplinks []*string `json:"standbyUplinks,omitempty" tf:"standby_uplinks,omitempty"`

	// A list of tag IDs to apply to this object.
	// +kubebuilder:validation:Optional
	// +listType=set
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, failover_explicit, or loadbalance_loadbased.
	// +kubebuilder:validation:Optional
	TeamingPolicy *string `json:"teamingPolicy,omitempty" tf:"teaming_policy,omitempty"`

	// Allow any traffic filters on
	// this port group to be overridden on an individual port.
	// Allow any filter policies set on the individual port to override those in the portgroup.
	// +kubebuilder:validation:Optional
	TrafficFilterOverrideAllowed *bool `json:"trafficFilterOverrideAllowed,omitempty" tf:"traffic_filter_override_allowed,omitempty"`

	// If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet forwarded done by the switch.
	// +kubebuilder:validation:Optional
	TxUplink *bool `json:"txUplink,omitempty" tf:"tx_uplink,omitempty"`

	// The port group type. Can be one of earlyBinding (static
	// binding) or ephemeral. Default: earlyBinding.
	// The type of portgroup. Can be one of earlyBinding (static) or ephemeral.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Allow the
	// uplink teaming options on this port group to be
	// overridden on an individual port.
	// Allow the uplink teaming policies on a port to override those on the portgroup.
	// +kubebuilder:validation:Optional
	UplinkTeamingOverrideAllowed *bool `json:"uplinkTeamingOverrideAllowed,omitempty" tf:"uplink_teaming_override_allowed,omitempty"`

	// The member VLAN for the ports this policy applies to. A
	// value of 0 means no VLAN.
	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	// +kubebuilder:validation:Optional
	VlanID *float64 `json:"vlanId,omitempty" tf:"vlan_id,omitempty"`

	// Allow the
	// VLAN settings on this port group to be overridden on an
	// individual port.
	// Allow the VLAN configuration on a port to override those on the portgroup.
	// +kubebuilder:validation:Optional
	VlanOverrideAllowed *bool `json:"vlanOverrideAllowed,omitempty" tf:"vlan_override_allowed,omitempty"`

	// Used to denote VLAN trunking. Use the min_vlan
	// and max_vlan sub-arguments to define the tagged VLAN range. Multiple
	// vlan_range definitions are allowed, but they must not overlap. Example
	// below:
	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	// +kubebuilder:validation:Optional
	VlanRange []VlanRangeParameters `json:"vlanRange,omitempty" tf:"vlan_range,omitempty"`
}

type VlanRangeInitParameters struct {

	// The minimum VLAN to use in the range.
	MaxVlan *float64 `json:"maxVlan,omitempty" tf:"max_vlan,omitempty"`

	// The minimum VLAN to use in the range.
	MinVlan *float64 `json:"minVlan,omitempty" tf:"min_vlan,omitempty"`
}

type VlanRangeObservation struct {

	// The minimum VLAN to use in the range.
	MaxVlan *float64 `json:"maxVlan,omitempty" tf:"max_vlan,omitempty"`

	// The minimum VLAN to use in the range.
	MinVlan *float64 `json:"minVlan,omitempty" tf:"min_vlan,omitempty"`
}

type VlanRangeParameters struct {

	// The minimum VLAN to use in the range.
	// +kubebuilder:validation:Optional
	MaxVlan *float64 `json:"maxVlan" tf:"max_vlan,omitempty"`

	// The minimum VLAN to use in the range.
	// +kubebuilder:validation:Optional
	MinVlan *float64 `json:"minVlan" tf:"min_vlan,omitempty"`
}

// VSphereDistributedPortGroupSpec defines the desired state of VSphereDistributedPortGroup
type VSphereDistributedPortGroupSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     VSphereDistributedPortGroupParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider VSphereDistributedPortGroupInitParameters `json:"initProvider,omitempty"`
}

// VSphereDistributedPortGroupStatus defines the observed state of VSphereDistributedPortGroup.
type VSphereDistributedPortGroupStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        VSphereDistributedPortGroupObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// VSphereDistributedPortGroup is the Schema for the VSphereDistributedPortGroups API. Provides a vSphere distributed port group resource. This can be used to create and manage port groups on a vSphere Distributed Switch.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,vsphere}
type VSphereDistributedPortGroup struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.distributedVirtualSwitchUuid) || (has(self.initProvider) && has(self.initProvider.distributedVirtualSwitchUuid))",message="spec.forProvider.distributedVirtualSwitchUuid is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	Spec   VSphereDistributedPortGroupSpec   `json:"spec"`
	Status VSphereDistributedPortGroupStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// VSphereDistributedPortGroupList contains a list of VSphereDistributedPortGroups
type VSphereDistributedPortGroupList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VSphereDistributedPortGroup `json:"items"`
}

// Repository type metadata.
var (
	VSphereDistributedPortGroup_Kind             = "VSphereDistributedPortGroup"
	VSphereDistributedPortGroup_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: VSphereDistributedPortGroup_Kind}.String()
	VSphereDistributedPortGroup_KindAPIVersion   = VSphereDistributedPortGroup_Kind + "." + CRDGroupVersion.String()
	VSphereDistributedPortGroup_GroupVersionKind = CRDGroupVersion.WithKind(VSphereDistributedPortGroup_Kind)
)

func init() {
	SchemeBuilder.Register(&VSphereDistributedPortGroup{}, &VSphereDistributedPortGroupList{})
}
